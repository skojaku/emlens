<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>emlens.metrics API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>emlens.metrics</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from joblib import Parallel, delayed
from sklearn.metrics import roc_curve
from sklearn import utils
from tqdm import tqdm
from .semaxis import calcSemAxis


def youden_separation_score(emb_a, emb_b):
    &#34;&#34;&#34;
    Calculate the level of separation between two sets of vectors using the Youden index.
    
    Given points of two classes (a, b), i.e., emb_a, emb_b, we project points onto a line
    using the LDA; LDA does so by maximizing the separation between two classes on the line.
    Then, we measure the level of separation of the two classes on the line.
    We consider class &#34;a&#34; as a positive class and the other class &#34;b&#34; as a negative class.
    Then, for the points on the line, we compute the Youden index.
    By running a threshold from one end of the line to the other end, we compute the true positive rate and false positive rate.
    The Youden index is given by maximum absolute difference between the true positive rate - false positive rate.
   
    Parameters
    ----------
    emb_a : numpy.array, shape=(num_point, dim)
        Embedding vectors for class a.
    emb_b : numpy.array, shape=(num_point, dim)
        Embedding vectors for class b.
   
    Returns
    -------
    score : float
        Youden index
    &#34;&#34;&#34;

    # Data label for LDA
    y = np.concatenate([np.ones(emb_a.shape[0]), np.zeros(emb_b.shape[0])])

    # Input data for LDA
    emb_ab = np.vstack([emb_a, emb_b])

    # Shuffle the data. This is to prevent overflow in sklearn&#39;s LDA which
    # sometimes happen when training and test data are the same
    emb_ab, y = utils.shuffle(emb_ab, y)

    # Embed poins onto a line
    x = calcSemAxis(emb_ab, emb_ab, labels=y, dim=1, mode=&#34;lda&#34;,)
    x = x.reshape(-1)

    # Calculate the ROC curve
    fpr, tpr, _ = roc_curve(y, x, 1)

    # Calculate the separation level
    score = np.max(np.abs(tpr - fpr))
    return score


def calc_pairwise_separation_score(
    emb,
    groups,
    separation_score_func=youden_separation_score,
    is_symmetric=True,
    n_jobs=20,
):
    &#34;&#34;&#34;
    Calculate the separation score for each pair of groups of vectors.
   
    Parameters
    ----------
    emb : numpy.array, shape=(num_point, dim)
        embedding vector
    groups : numpy.array, shape=(num_point,)
        group membership for points. Can be integer or string
        calc_separation_score
    separation_score_func : function
        Function to compute the separation score. This function takes two arguments, emb_a and emb_b, and
        compute the separation level for the two vectors.
    is_symmetric : bool (Optional; Default True)
        Set True if the separation score is symmetric with respect to the groups, i.e., the score does not change
        when we swap the class labels.
    n_jobs : int (Optional; Default 20)
        Number of cores
       
    Returns
    -------
    separation_matrix : numpy.array, shape=(num_groups, num_groups)
        separation_matrix[i,j] indicates the sepration level of group_labels[i] and group_labels[j].
    group_labels : numpy.array
        List of groups.
    &#34;&#34;&#34;
    group_labels = np.unique(groups)
    num_groups = len(group_labels)

    wrap_func = lambda _i, _j, emb_a, emb_b: (
        _i,
        _j,
        separation_score_func(emb_a, emb_b),
    )

    tasks = []
    for i, group_i in enumerate(group_labels):
        for j, group_j in enumerate(group_labels):
            if is_symmetric and j &lt;= i:
                continue
            tasks += [
                delayed(wrap_func)(
                    i, j, emb[groups == group_i, :], emb[groups == group_j, :]
                )
            ]

    results = Parallel(n_jobs=n_jobs)(tasks)
    separation_matrix = np.zeros((num_groups, num_groups))
    for result in results:
        i, j, score = result
        separation_matrix[i, j] = score

    if is_symmetric:
        separation_matrix += separation_matrix.T
    return separation_matrix, group_labels</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="emlens.metrics.calc_pairwise_separation_score"><code class="name flex">
<span>def <span class="ident">calc_pairwise_separation_score</span></span>(<span>emb, groups, separation_score_func=&lt;function youden_separation_score&gt;, is_symmetric=True, n_jobs=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the separation score for each pair of groups of vectors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emb</code></strong> :&ensp;<code>numpy.array, shape=(num_point, dim)</code></dt>
<dd>embedding vector</dd>
<dt><strong><code>groups</code></strong> :&ensp;<code>numpy.array, shape=(num_point,)</code></dt>
<dd>group membership for points. Can be integer or string
calc_separation_score</dd>
<dt><strong><code>separation_score_func</code></strong> :&ensp;<code>function</code></dt>
<dd>Function to compute the separation score. This function takes two arguments, emb_a and emb_b, and
compute the separation level for the two vectors.</dd>
<dt><strong><code>is_symmetric</code></strong> :&ensp;<code>bool (Optional; Default True)</code></dt>
<dd>Set True if the separation score is symmetric with respect to the groups, i.e., the score does not change
when we swap the class labels.</dd>
<dt><strong><code>n_jobs</code></strong> :&ensp;<code>int (Optional; Default 20)</code></dt>
<dd>Number of cores</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>separation_matrix</code></strong> :&ensp;<code>numpy.array, shape=(num_groups, num_groups)</code></dt>
<dd>separation_matrix[i,j] indicates the sepration level of group_labels[i] and group_labels[j].</dd>
<dt><strong><code>group_labels</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>List of groups.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_pairwise_separation_score(
    emb,
    groups,
    separation_score_func=youden_separation_score,
    is_symmetric=True,
    n_jobs=20,
):
    &#34;&#34;&#34;
    Calculate the separation score for each pair of groups of vectors.
   
    Parameters
    ----------
    emb : numpy.array, shape=(num_point, dim)
        embedding vector
    groups : numpy.array, shape=(num_point,)
        group membership for points. Can be integer or string
        calc_separation_score
    separation_score_func : function
        Function to compute the separation score. This function takes two arguments, emb_a and emb_b, and
        compute the separation level for the two vectors.
    is_symmetric : bool (Optional; Default True)
        Set True if the separation score is symmetric with respect to the groups, i.e., the score does not change
        when we swap the class labels.
    n_jobs : int (Optional; Default 20)
        Number of cores
       
    Returns
    -------
    separation_matrix : numpy.array, shape=(num_groups, num_groups)
        separation_matrix[i,j] indicates the sepration level of group_labels[i] and group_labels[j].
    group_labels : numpy.array
        List of groups.
    &#34;&#34;&#34;
    group_labels = np.unique(groups)
    num_groups = len(group_labels)

    wrap_func = lambda _i, _j, emb_a, emb_b: (
        _i,
        _j,
        separation_score_func(emb_a, emb_b),
    )

    tasks = []
    for i, group_i in enumerate(group_labels):
        for j, group_j in enumerate(group_labels):
            if is_symmetric and j &lt;= i:
                continue
            tasks += [
                delayed(wrap_func)(
                    i, j, emb[groups == group_i, :], emb[groups == group_j, :]
                )
            ]

    results = Parallel(n_jobs=n_jobs)(tasks)
    separation_matrix = np.zeros((num_groups, num_groups))
    for result in results:
        i, j, score = result
        separation_matrix[i, j] = score

    if is_symmetric:
        separation_matrix += separation_matrix.T
    return separation_matrix, group_labels</code></pre>
</details>
</dd>
<dt id="emlens.metrics.youden_separation_score"><code class="name flex">
<span>def <span class="ident">youden_separation_score</span></span>(<span>emb_a, emb_b)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the level of separation between two sets of vectors using the Youden index.</p>
<p>Given points of two classes (a, b), i.e., emb_a, emb_b, we project points onto a line
using the LDA; LDA does so by maximizing the separation between two classes on the line.
Then, we measure the level of separation of the two classes on the line.
We consider class "a" as a positive class and the other class "b" as a negative class.
Then, for the points on the line, we compute the Youden index.
By running a threshold from one end of the line to the other end, we compute the true positive rate and false positive rate.
The Youden index is given by maximum absolute difference between the true positive rate - false positive rate.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emb_a</code></strong> :&ensp;<code>numpy.array, shape=(num_point, dim)</code></dt>
<dd>Embedding vectors for class a.</dd>
<dt><strong><code>emb_b</code></strong> :&ensp;<code>numpy.array, shape=(num_point, dim)</code></dt>
<dd>Embedding vectors for class b.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>score</code></strong> :&ensp;<code>float</code></dt>
<dd>Youden index</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def youden_separation_score(emb_a, emb_b):
    &#34;&#34;&#34;
    Calculate the level of separation between two sets of vectors using the Youden index.
    
    Given points of two classes (a, b), i.e., emb_a, emb_b, we project points onto a line
    using the LDA; LDA does so by maximizing the separation between two classes on the line.
    Then, we measure the level of separation of the two classes on the line.
    We consider class &#34;a&#34; as a positive class and the other class &#34;b&#34; as a negative class.
    Then, for the points on the line, we compute the Youden index.
    By running a threshold from one end of the line to the other end, we compute the true positive rate and false positive rate.
    The Youden index is given by maximum absolute difference between the true positive rate - false positive rate.
   
    Parameters
    ----------
    emb_a : numpy.array, shape=(num_point, dim)
        Embedding vectors for class a.
    emb_b : numpy.array, shape=(num_point, dim)
        Embedding vectors for class b.
   
    Returns
    -------
    score : float
        Youden index
    &#34;&#34;&#34;

    # Data label for LDA
    y = np.concatenate([np.ones(emb_a.shape[0]), np.zeros(emb_b.shape[0])])

    # Input data for LDA
    emb_ab = np.vstack([emb_a, emb_b])

    # Shuffle the data. This is to prevent overflow in sklearn&#39;s LDA which
    # sometimes happen when training and test data are the same
    emb_ab, y = utils.shuffle(emb_ab, y)

    # Embed poins onto a line
    x = calcSemAxis(emb_ab, emb_ab, labels=y, dim=1, mode=&#34;lda&#34;,)
    x = x.reshape(-1)

    # Calculate the ROC curve
    fpr, tpr, _ = roc_curve(y, x, 1)

    # Calculate the separation level
    score = np.max(np.abs(tpr - fpr))
    return score</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="emlens" href="index.html">emlens</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="emlens.metrics.calc_pairwise_separation_score" href="#emlens.metrics.calc_pairwise_separation_score">calc_pairwise_separation_score</a></code></li>
<li><code><a title="emlens.metrics.youden_separation_score" href="#emlens.metrics.youden_separation_score">youden_separation_score</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>